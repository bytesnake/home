<!DOCTYPE html> 
<html  lang="en-US" xml:lang="en-US" > 
<head> <title>Theorem Tavern</title> 
<meta   charset="utf-8" /> 
<meta  name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta  name="viewport" content="width=device-width,initial-scale=1" /> 
<link  rel="stylesheet" type="text/css" href="thmtav.css" /> 
<meta  name="src" content="thmtav.tex"> 
</head><body  
>
<!--l. 51--><p  class="noindent" ><a  
 id="refsection:1"></a><a  
 id="x1-1doc"></a><a  
 id="x1-2r1"></a>
   <div  class="newtheorem">
<!--l. 51--><p  class="noindent" ><span  class="head">
<a  
 id="f6izn8iw"></a>
<span  
class="cmbx-10">Definition – </span>Proximal Operator<br  
class="newline" /> </span><a  
 id="x1-4"></a><a  
 id="f6izn8iw"></a>The  proximal  operator  (also  called  proximal  mapping),
also see resolvant for CCP case, is given by
   <table  class="equation-star"><tr><td>
<!--l. 54--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                <msub><mrow  
><mi  class="qopname">prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>λ</mi><mi  
>f</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> argmin</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>y</mi></mrow></munder 
> <mrow><mo  fence="true" form="prefix"> {</mo><mrow><mi  
>Θ</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-punc" stretchy="false">;</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>λ</mi><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
></mrow><mo  fence="true" form="postfix">}</mo></mrow>
</math></td></tr></table>
<!--l. 58--><p  class="indent" >   <a  
 id="refsection:2"></a><a  
 id="x1-5r2"></a>
   <div  class="newtheorem">
<!--l. 58--><p  class="noindent" ><span  class="head">
<a  
 id="78req5r7"></a>
<span  
class="cmbx-10">Satz – </span>Convergence with Lyapunov Analysis<br  
class="newline" /> </span><a  
 id="x1-7"></a><a  
 id="78req5r7"></a>Let
<!--l. 59--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>F</mi></mstyle></mrow><mrow  
><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>∞</mi></mrow></msub 
></mrow></math>. For any
<!--l. 59--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>k</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mi  
>ℕ</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math> and
any <!--l. 59--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
></mrow></math>,
the inequality
<!--tex4ht:inline--><!--l. 63--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable  
displaystyle="true" columnalign="left" class="alignat-star">
                     <mtr><mtd  
columnalign="right" class="align-odd"></mtd>                       <mtd  
class="align-even"><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-bin" stretchy="false">+</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mfrac><mrow  
><mn>1</mn></mrow>
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msub 
><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label">
                     <mspace  width="2em"/></mtd></mtr><mtr><mtd  
columnalign="right" class="align-odd"> <mo  
class="MathClass-rel" stretchy="false">≤</mo></mtd>                     <mtd  
class="align-even"><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-bin" stretchy="false">+</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mfrac><mrow  
><mn>1</mn></mrow>
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
>
<mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label">
   <mspace  width="2em"/></mtd></mtr></mtable></math>
<!--l. 64--><p  class="noindent" >holds for iteration <!--l. 64--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mi  
>f</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
and number <!--l. 64--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
></mrow></math>.
<!--l. 65--><p  class="indent" >   <a  
 id="refsection:3"></a></div>
<!--l. 65--><p  class="indent" >
<!--l. 67--><p  class="indent" >   <a  
 id="refsection:4"></a><a  
 id="x1-8r3"></a>
   <div  class="newtheorem">
<!--l. 67--><p  class="noindent" ><span  class="head">
<a  
 id="hnns6j86"></a>
<span  
class="cmbx-10">Remark – </span>Computation complexity<br  
class="newline" /> </span><a  
 id="x1-10"></a><a  
 id="hnns6j86"></a><a  
href="#f6izn8iw">Proximal   operations</a>   are   in   general   expensive,
sometimes                                                                                                       as
expensive as minimizing the function itself. There are however many instances of function
<!--l. 70--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi></mrow></math>
for which an analytic solution exists. For composite problems, those parts are isolated and
solved separately by a conceptional proximal operator.
<!--l. 73--><p  class="indent" >   <a  
 id="refsection:5"></a></div>
<!--l. 73--><p  class="indent" >
<!--l. 74--><p  class="indent" >   <a  
 id="refsection:6"></a></div>
<!--l. 74--><p  class="indent" >   <a  
 id="refsection:7"></a><a  
 id="x1-9rdoc"></a><a  
 id="x1-11r4"></a>
   <div  class="newtheorem">
<!--l. 75--><p  class="noindent" ><span  class="head">
<a  
 id="g87jzem_"></a>
<span  
class="cmbx-10">Definition – </span>Closed Convex Proper<br  
class="newline" /> </span><a  
 id="x1-13"></a><a  
 id="g87jzem_"></a>A collective term for functions which are closed, convex
and proper. This family includes most function encountered in application and excludes
special cases found in analysis.
<!--l. 77--><p  class="indent" >   <a  
 id="refsection:8"></a></div>
<!--l. 77--><p  class="indent" >   <a  
 id="refsection:9"></a><a  
 id="x1-12rdoc"></a><a  
 id="x1-14r5"></a>
   <div  class="newtheorem">
<!--l. 78--><p  class="noindent" ><span  class="head">
<a  
 id="5nalj3hx"></a>
<span  
class="cmbx-10">Definition – </span>Lipschitz Regularity<br  
class="newline" /> </span><a  
 id="x1-16"></a><a  
 id="5nalj3hx"></a>For <!--l. 79--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math>,
we say that a mapping <!--l. 79--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-punc" stretchy="false">:</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">→</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>m</mi></mrow></msup 
></mrow></math>
is L-Lipschitz if globally <table  class="equation-star"><tr><td>
<!--l. 80--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                      <mo  
class="MathClass-rel" stretchy="false">∥</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mspace  width="2em" class="qquad"/><mi  
class="MathClass-op">∀</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>x</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>y</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 83--><p  class="indent" >   If a mapping is Lipschitz, it is a continuous mapping because for every <!--l. 84--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>δ</mi></mrow></math>
exists <!--l. 84--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>𝜖</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>L</mi><mi  
>δ</mi></mrow></math>.
The composition of <!--l. 84--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
></mrow></math>
and <!--l. 84--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
<!--l. 85--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">∘</mo><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
is <!--l. 85--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>-Lipschitz
(<span  
class="cmti-10">hint </span>apply Lipschitz inequality twice). The sum of two mappings, <!--l. 86--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>
is <!--l. 86--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>-Lipschitz.
<!--l. 88--><p  class="indent" >   <a  
 id="refsection:10"></a><a  
 id="x1-17r6"></a>
   <div  class="newtheorem">
<!--l. 88--><p  class="noindent" ><span  class="head">
<a  
 id="17vzrkyq"></a>
<span  
class="cmbx-10">Beispiel – </span>Affine Function<br  
class="newline" /> </span><a  
 id="x1-19"></a><a  
 id="17vzrkyq"></a>An affine function <!--l. 89--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>F</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>A</mi><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mi  
>b</mi></mrow></math>
has Lipschitz constant <!--l. 89--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>A</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
the spectral norm or maximum singular value of <!--l. 90--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>A</mi></mrow></math>.
                                                                            
                                                                            
<!--l. 91--><p  class="indent" >   <a  
 id="refsection:11"></a></div>
<!--l. 91--><p  class="indent" >
<!--l. 93--><p  class="indent" >   <a  
 id="refsection:12"></a><a  
 id="x1-20r7"></a>
   <div  class="newtheorem">
<!--l. 93--><p  class="noindent" ><span  class="head">
<a  
 id="jydhwyqa"></a>
<span  
class="cmbx-10">Beispiel – </span>Differentiable Function<br  
class="newline" /> </span><a  
 id="x1-22"></a><a  
 id="jydhwyqa"></a>Let <!--l. 94--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-punc" stretchy="false">:</mo><msup><mrow  
> <mstyle  
mathvariant="script"><mi  
>R</mi></mstyle></mrow><mrow  
><mi  
>n</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">→</mo><msup><mrow  
><mstyle  
mathvariant="script"><mi  
>R</mi></mstyle></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>
be a differentiable function, then <table  class="equation-star"><tr><td>
<!--l. 95--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                          <mstyle  
class="text"><mtext   >L-Lipschitz</mtext></mstyle><mspace  width="1em" class="quad"/> <mo  
class="MathClass-rel" stretchy="false">↔</mo><mspace  width="1em" class="quad"/><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  class="qopname">D</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi>
</math></td></tr></table>
   <div  class="tabular"> <table  id="TBL-1" class="tabular" 
 
><colgroup  id="TBL-1-1g"><col  
id="TBL-1-1"><col  
id="TBL-1-2"></colgroup><tr   
 style="vertical-align:baseline;" id="TBL-1-1-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-1-1"  
class="td11">For a proof</td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-1-2"  
class="td11">(<!--l. 100--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mspace  width="0.28em" class="thickpace"/><mo  
class="MathClass-rel" stretchy="false">⟹</mo><mspace  width="0.28em" class="thickpace"/></mrow></math>) bound definition of differentials                                        </td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-2-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-2-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-2-2"  
class="td11">(<!--l. 101--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mspace  width="0.28em" class="thickpace"/><mo  
class="MathClass-rel" stretchy="false">⟸</mo><mspace  width="0.28em" class="thickpace"/></mrow></math>) apply mean value theorem and Cauchy-Schwartz inequality to</td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-3-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-3-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-3-2"  
class="td11">  <!--l. 103--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>                                                                                  </td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-4-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-4-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-4-2"  
class="td11">  (with <!--l. 104--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>y</mi><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mn>0</mn><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>)                                                                         </td> </tr></table></div>
<!--l. 106--><p  class="indent" >   <a  
 id="refsection:13"></a></div>
<!--l. 106--><p  class="indent" >
<!--l. 108--><p  class="indent" >   <a  
 id="refsection:14"></a><a  
 id="x1-23r8"></a>
   <div  class="newtheorem">
<!--l. 108--><p  class="noindent" ><span  class="head">
<a  
 id="5pxh2ufj"></a>
<span  
class="cmbx-10">Beispiel – </span>Projections<br  
class="newline" /> </span><a  
 id="x1-25"></a><a  
 id="5pxh2ufj"></a>The projection of <!--l. 109--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
onto a non-empty closed convex set <!--l. 109--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></math>
is defined as <table  class="equation-star"><tr><td>
<!--l. 111--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                   <msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> argmin</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></munder 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>z</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  class="qopname">I</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 115--><p  class="indent" >   and a <a  
href="#2s6tfa1j">non-expansive</a> operator with unique closest point in <!--l. 116--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></math>.
<!--l. 118--><p  class="indent" >   For a proof see that the closest projection of <!--l. 118--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
is a fixed-point <!--l. 119--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>
and the differential <!--l. 120--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></msub 
><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"> dist</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>.
Apply the optimality condition
<!--l. 125--><p  class="indent" >
<!--tex4ht:inline--><!--l. 128--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable  
displaystyle="true" columnalign="left" class="alignat-star">
                            <mtr><mtd  
columnalign="right" class="align-odd"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  class="qopname">D</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
></mtd>                            <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                               <mtd  
columnalign="right" class="align-odd"></mtd>                            <mtd  
class="align-even"> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mn>0</mn><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label"><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label">
                            <mspace  width="2em"/></mtd></mtr><mtr><mtd  
columnalign="right" class="align-odd"><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>u</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
></mtd>                            <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script">
<mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-odd"></mtd>                            <mtd  
class="align-even"> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mn>0</mn><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label"><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label">
   <mspace  width="2em"/></mtd></mtr></mtable></math>
at two points <!--l. 129--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>y</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>.
Adding both, apply Cauchy-Schwartz inequality to conclude <table  class="equation-star"><tr><td>
<!--l. 131--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                           <mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>y</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">≤</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
   <a  
 id="refsection:15"></a></div>
<!--l. 135--><p  class="indent" >
<!--l. 137--><p  class="indent" >   <a  
 id="refsection:16"></a><a  
 id="x1-26r9"></a>
   <div  class="newtheorem">
<!--l. 137--><p  class="noindent" ><span  class="head">
<a  
 id="2s6tfa1j"></a>
<span  
class="cmbx-10">Remark – </span>Nonexpansive and Contractive Mappings<br  
class="newline" /> </span><a  
 id="x1-28"></a><a  
 id="2s6tfa1j"></a>A mapping is called nonexpansive for
<!--l. 138--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mn>1</mn></mrow></math>,
contractive for <!--l. 139--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>.
<!--l. 140--><p  class="indent" >   <a  
 id="refsection:17"></a></div>
<!--l. 140--><p  class="indent" >
<!--l. 141--><p  class="indent" >   <a  
 id="refsection:18"></a></div>
<!--l. 141--><p  class="indent" >   <a  
 id="refsection:19"></a><a  
 id="x1-27rdoc"></a><a  
 id="x1-29r10"></a>
   <div  class="newtheorem">
<!--l. 142--><p  class="noindent" ><span  class="head">
<a  
 id="ceh4aors"></a>
<span  
class="cmbx-10">Definition – </span>L-Smooth (<span  
class="cmti-10">o</span>r L-Lipschitz Continuous Gradient)<br  
class="newline" /> </span><a  
 id="x1-31"></a><a  
 id="ceh4aors"></a>Lipschitz regularity for the gradient
of a function is called a L-Lipschitz continuous gradient (or L-smooth) function with
<!--l. 144--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math>
<table  class="equation-star"><tr><td>
                                                                            
                                                                            
<!--l. 145--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                         <mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 149--><p  class="indent" >   <a  
 id="refsection:20"></a><a  
 id="x1-32r11"></a>
   <div  class="newtheorem">
<!--l. 149--><p  class="noindent" ><span  class="head">
<a  
 id="5vsiv5i2"></a>
<span  
class="cmbx-10">Remark – </span>Cocoerciveness of L-Smooth functions<br  
class="newline" /> </span><a  
 id="x1-34"></a><a  
 id="5vsiv5i2"></a>For  a  convex  function  (L-Smootheness
<!--l. 150--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">⟺</mo></mrow></math>
1/L-cocoerciveness of gradients).
<!--l. 153--><p  class="indent" >   <span  
class="cmti-10">Proof sketch </span>Use inequality <!--l. 153--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn><mi  
>L</mi></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msup 
></mrow></math>
(which is implied by L-smootheness when function convex). Evaluate function at two points
<table  class="equation-star"><tr><td>
<!--l. 157--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                <msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>x</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>z</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow><mspace  width="1em" class="quad"/><mstyle  
class="text"><mtext   >and</mtext></mstyle><mspace  width="1em" class="quad"/><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>y</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>z</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow>
</math></td></tr></table>
<!--l. 161--><p  class="indent" >   and
combine both inequalities to show co-coerciveness. This can also be seen from the relation
<!--l. 162--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>∂</mi><mi  
>f</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>∂</mi><msup><mrow  
><mi  
>f</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>
for CCP functions.
<!--l. 164--><p  class="indent" >   <a  
 id="refsection:21"></a></div>
<!--l. 164--><p  class="indent" >
<!--l. 166--><p  class="indent" >   <a  
 id="refsection:22"></a><a  
 id="x1-35r12"></a>
   <div  class="newtheorem">
<!--l. 166--><p  class="noindent" ><span  class="head">
<a  
 id="2tz2l_0t"></a>
<span  
class="cmbx-10">Literature –</span><br  
class="newline" /> </span><a  
 id="x1-37"></a><a  
 id="2tz2l_0t"></a>A good overview of continuous gradient under various conditions can be found
at the blog post [<a  
 id="x1-38"></a><a  
href="#cite.22@zhou_continuous_gradient">Zho</a>], also see [<a  
 id="x1-39"></a> <a  
href="#cite.22@acceleration_methods">dST21</a>,  <a  
href="https://arxiv.org/pdf/2101.09545.pdf#theorem.A.1.1" >Appendix A</a> ]. Further [<a  
 id="x1-40"></a> <a  
href="#cite.22@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#theorem.3.4" >connections</a> ] of
smoothness to [ <a  
href="#cite.22@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#equation.3.13" >expected-smoothness</a> ] and [ <a  
href="#cite.22@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#assumption.3.1" >expected residual</a> ] exist. Also
the [<a  
 id="x1-41"></a> <a  
href="#cite.22@garrigos2023handbook">GG23</a>,  <a  
href="https://arxiv.org/pdf/2301.11235.pdf#subsection.2.5" >Section 2.5</a> ] lists a number of compact proofs for smoothness and smoothness
under convexity.
          <dl  class="thebibliography"><dt  id="X22-acceleration_methods" class="thebibliography">
[dST21]   </dt><dd  
id="bib-1" class="thebibliography">
          <!--l. 169--><p  class="noindent" ><a  
 id="cite.22@acceleration_methods"></a>Alexandre d’Aspremont, Damien Scieur, and Adrien B. Taylor. “Acceleration
          Methods”.  In:  <span  
class="cmti-10">CoRR  </span>abs/2101.09545  (2021).  arXiv:  <a  
href="https://arxiv.org/abs/2101.09545" ><span  
class="cmtt-10">2101 . 09545</span></a>.  <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://arxiv.org/pdf/2101.09545.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2101.09545.pdf</span></a>.
          </dd><dt  id="X22-garrigos2023handbook" class="thebibliography">
[GG23]    </dt><dd  
id="bib-2" class="thebibliography">
          <!--l. 169--><p  class="noindent" ><a  
 id="cite.22@garrigos2023handbook"></a>Guillaume Garrigos and Robert M. Gower. <span  
class="cmti-10">Handbook of Convergence Theorems</span>
          <span  
class="cmti-10">for (Stochastic) Gradient Methods</span>. 2023. arXiv: <a  
href="https://arxiv.org/abs/2301.11235" ><span  
class="cmtt-10">2301.11235 [math.OC]</span></a>. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://arxiv.org/pdf/2301.11235.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2301.11235.pdf</span></a>.
          </dd><dt  id="X22-structured_nonconvex_functions" class="thebibliography">
[GSL21]   </dt><dd  
id="bib-3" class="thebibliography">
          <!--l. 169--><p  class="noindent" ><a  
 id="cite.22@structured_nonconvex_functions"></a>Robert M. Gower, Othmane Sebbouh, and Nicolas Loizou. “SGD for Structured
          Nonconvex Functions: Learning Rates, Minibatching and Interpolation”. In: <span  
class="cmti-10">The</span>
          <span  
class="cmti-10">24th International Conference on Artificial Intelligence and Statistics, AISTATS</span>
          <span  
class="cmti-10">2021, April 13-15, 2021, Virtual Event</span>. Ed. by Arindam Banerjee and Kenji
          Fukumizu. Vol. 130. Proceedings of Machine Learning Research. PMLR, 2021,
          pp. 1315–1323. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://arxiv.org/pdf/2006.10311.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2006.10311.pdf</span></a>.
          </dd><dt  id="X22-zhou_continuous_gradient" class="thebibliography">
[Zho]     </dt><dd  
id="bib-4" class="thebibliography">
          <!--l. 169--><p  class="noindent" ><a  
 id="cite.22@zhou_continuous_gradient"></a>Xingyu         Zhou.         <span  
class="cmti-10">Lipschitz        continuous        gradient</span>.         <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://xingyuzhou.org/blog/notes/Lipschitz-gradient" class="url" ><span  
class="cmtt-10">https://xingyuzhou.org/blog/notes/Lipschitz-gradient</span></a>.</dd></dl>
<!--l. 169--><p  class="indent" >   <a  
 id="refsection:23"></a></div>
<!--l. 169--><p  class="indent" >
<!--l. 170--><p  class="indent" >   <a  
 id="refsection:24"></a></div>
<!--l. 170--><p  class="indent" >   <a  
 id="refsection:25"></a><a  
 id="x1-36rdoc"></a><a  
 id="x1-42r13"></a>
   <div  class="newtheorem">
<!--l. 171--><p  class="noindent" ><span  class="head">
<a  
 id="3m5jm_az"></a>
<span  
class="cmbx-10">Definition – </span>Quasar Convex<br  
class="newline" /> </span><a  
 id="x1-44"></a><a  
 id="3m5jm_az"></a>Let <!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>ζ</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">]</mo></mrow></math>
and <!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">∈</mo><msup><mrow  
><mstyle  
mathvariant="script"><mi  
>X</mi></mstyle></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>. We
say that <!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi></mrow></math>
<!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>ζ</mi></mrow></math>-quasar-convex
with respect to <!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>
if for all <!--l. 172--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>,
<table  class="equation-star"><tr><td>
<!--l. 173--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mi  
>ζ</mi></mrow></mfrac> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 177--><p  class="indent" >   <a  
 id="refsection:26"></a><a  
 id="x1-45r14"></a>
   <div  class="newtheorem">
<!--l. 177--><p  class="noindent" ><span  class="head">
<a  
 id="c9swuw97"></a>
<span  
class="cmbx-10">Literature –</span><br  
class="newline" /> </span><a  
 id="x1-47"></a><a  
 id="c9swuw97"></a>Convergence analysis of quasar-convex functions exists with [ <a  
href="#cite.26@structured_nonconvex_functions">GSL21</a>, <a  
href="https://arxiv.org/pdf/2006.10311.pdf#subsection.4.1" >constant
and decreasing</a> ] step-sizes. Evaluation of star-convexity for NMF can be found in [<a  
 id="x1-48"></a><a  
href="#cite.26@star_convexity_nmf">BGW20</a>].
For variance transfer under non-convexity see [<a  
 id="x1-49"></a> <a  
href="#cite.26@sgd_arbitrary_sampling">Qia+19</a>,  <a  
href="http://proceedings.mlr.press/v97/qian19b.html#example.2.2" >Example 2.2</a> ].
                                                                            
                                                                            
          <dl  class="thebibliography"><dt  id="X26-star_convexity_nmf" class="thebibliography">
[BGW20]  </dt><dd  
id="bib-5" class="thebibliography">
          <!--l. 179--><p  class="noindent" ><a  
 id="cite.26@star_convexity_nmf"></a>Johan                Bjorck,                Carla                Gomes,                and
          Kilian Weinberger. <span  
class="cmti-10">Star-Convexity in Non-Negative Matrix Factorization</span>. 2020.
          <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://openreview.net/pdf?id=BylKwnEYvS" class="url" ><span  
class="cmtt-10">https://openreview.net/pdf?id=BylKwnEYvS</span></a>.
          </dd><dt  id="X26-structured_nonconvex_functions" class="thebibliography">
[GSL21]   </dt><dd  
id="bib-6" class="thebibliography">
          <!--l. 179--><p  class="noindent" ><a  
 id="cite.26@structured_nonconvex_functions"></a>Robert M. Gower, Othmane Sebbouh, and Nicolas Loizou. “SGD for Structured
          Nonconvex Functions: Learning Rates, Minibatching and Interpolation”. In: <span  
class="cmti-10">The</span>
          <span  
class="cmti-10">24th International Conference on Artificial Intelligence and Statistics, AISTATS</span>
          <span  
class="cmti-10">2021, April 13-15, 2021, Virtual Event</span>. Ed. by Arindam Banerjee and Kenji
          Fukumizu. Vol. 130. Proceedings of Machine Learning Research. PMLR, 2021,
          pp. 1315–1323. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://arxiv.org/pdf/2006.10311.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2006.10311.pdf</span></a>.
          </dd><dt  id="X26-sgd_arbitrary_sampling" class="thebibliography">
[Qia+19]  </dt><dd  
id="bib-7" class="thebibliography">
          <!--l. 179--><p  class="noindent" ><a  
 id="cite.26@sgd_arbitrary_sampling"></a>Xun  Qian  et  al.  “SGD  with  Arbitrary  Sampling:  General  Analysis  and
          Improved  Rates”.  In:  <span  
class="cmti-10">Proceedings  of  the  36th  International  Conference  on</span>
          <span  
class="cmti-10">Machine  Learning,  ICML  2019,  9-15  June  2019,  Long  Beach,  California,</span>
          <span  
class="cmti-10">USA</span>.  Ed.  by  Kamalika  Chaudhuri  and  Ruslan  Salakhutdinov.  Vol. 97.
          Proceedings of Machine Learning Research. PMLR, 2019, pp. 5200–5209. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="http://proceedings.mlr.press/v97/qian19b.html" class="url" ><span  
class="cmtt-10">http://proceedings.mlr.press/v97/qian19b.html</span></a>.</dd></dl>
<!--l. 179--><p  class="indent" >   <a  
 id="refsection:27"></a></div>
<!--l. 179--><p  class="indent" >
<!--l. 180--><p  class="indent" >   <a  
 id="refsection:28"></a></div>
<!--l. 180--><p  class="indent" >   <a  
 id="refsection:29"></a><a  
 id="x1-46rdoc"></a><a  
 id="x1-50r15"></a>
   <div  class="newtheorem">
<!--l. 181--><p  class="noindent" ><span  class="head">
<a  
 id="v_o4l6wn"></a>
<span  
class="cmbx-10">Definition – </span>Asymptotic Convergence Rates<br  
class="newline" /> </span><a  
 id="x1-52"></a><a  
 id="v_o4l6wn"></a>Notions of sub-linear, linear and super-linear
(esp.  quadratic)  convergence  rates  are  important  taxonomy  to  discuss  the  efficiency  of
optimization algorithms.
<!--l. 184--><p  class="indent" >   A sequence of vectors <!--l. 184--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo></mrow></math> is said
to converge to a limit point <!--l. 184--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>
     <ul  class="itemize1">
     <li  class="itemize">
     <!--l. 186--><p  class="noindent" ><span  
class="cmti-10">sub-linear </span>if for some <!--l. 186--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 186--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mi  
>p</mi></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>∞</mi></mrow></math>,
     each new correct digit takes approximately the same amount of total work already
     done for previous digits
     </li>
     <li  class="itemize">
     <!--l. 187--><p  class="noindent" ><span  
class="cmti-10">linearly </span>if for some <!--l. 187--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>ρ</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 187--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>1</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mi  
>ρ</mi></mrow></math>,
     each new correct digit takes the <span  
class="cmti-10">same amount </span>of time
     </li>
     <li  class="itemize">
     <!--l. 188--><p  class="noindent" ><span  
class="cmti-10">super-linear </span>if <!--l. 188--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>1</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mn>0</mn></mrow></math>
     </li>
     <li  class="itemize">
     <!--l. 189--><p  class="noindent" ><span  
class="cmti-10">quadratic </span>if for some <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>ρ</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>2</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mi  
>ρ</mi></mrow></math>,
     every iteration the correct number of digits approximately doubles
     </li>
     <li  class="itemize">
     <!--l. 190--><p  class="noindent" ><span  
class="cmti-10">linear-quadratic </span>if for some <!--l. 190--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     and <!--l. 190--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>
     the inequality holds: <table  class="equation-star"><tr><td>
     <!--l. 191--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                <mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
>
<mn>2</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msup 
>
</math></td></tr></table>
     </li></ul>
<!--l. 195--><p  class="noindent" >where we define the rate of convergence as <table  class="equation-star"><tr><td>
<!--l. 196--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                      <msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mi  
>p</mi></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> lim</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
>
<mi  
>t</mi><mo  
class="MathClass-rel" stretchy="false">→</mo><mi  
>∞</mi></mrow></munder 
><mi  class="qopname">sup</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo> <mfrac><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow> 
<mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mi  
>p</mi></mrow></msup 
></mrow></mfrac> <mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 200--><p  class="indent" >   Clearly quadratic convergence is an instance of super-linear convergence.
<!--l. 202--><p  class="indent" >   <a  
 id="refsection:30"></a><a  
 id="x1-53r16"></a>
   <div  class="newtheorem">
<!--l. 202--><p  class="noindent" ><span  class="head">
<a  
 id="ok2t_031"></a>
<span  
class="cmbx-10">Beispiel – </span>Sublinear Convergence in First-Order Methods<br  
class="newline" /> </span><a  
 id="x1-55"></a><a  
 id="ok2t_031"></a>Asymptotic  rates  discusses  the
case when <!--l. 203--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
></mrow></math>
approaches <!--l. 203--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>.
For many first-order methods, this is not really relevant, as only a small number of iterations
are possible [<a  
 id="x1-56"></a><a  
href="#cite.30@sublinear_rate">Bor23</a>].
          <dl  class="thebibliography"><dt  id="X30-sublinear_rate" class="thebibliography">
[Bor23]    </dt><dd  
id="bib-8" class="thebibliography">
          <!--l. 204--><p  class="noindent" ><a  
 id="cite.30@sublinear_rate"></a>Brian          Borchers.          <span  
class="cmti-10">Sublinear         rate         of         convergence</span>
          <span  
class="cmti-10">in mathematical optimization</span>. [Online; accessed 19. Dec. 2023]. Dec. 2023. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://math.stackexchange.com/a/2615629" class="url" ><span  
class="cmtt-10">https://math.stackexchange.com/a/2615629</span></a>.</dd></dl>
<!--l. 204--><p  class="indent" >   <a  
 id="refsection:31"></a></div>
<!--l. 204--><p  class="indent" >
                                                                            
                                                                            
   <a  
 id="refsection:32"></a></div>
<!--l. 206--><p  class="indent" >
<!--l. 208--><p  class="noindent" ><a  
 id="refsection:33"></a><a  
 id="x1-54rdoc"></a><a  
 id="x1-57r17"></a>
   <div  class="newtheorem">
<!--l. 208--><p  class="noindent" ><span  class="head">
<a  
 id="h9xvj58r"></a>
<span  
class="cmbx-10">Definition – </span>Newton Method<br  
class="newline" /> </span><a  
 id="x1-59"></a><a  
 id="h9xvj58r"></a>Consider the finite-sum minimization problem <table  class="equation-star"><tr><td>
<!--l. 210--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <munder  class="msub"><mrow  
><mi  class="qopname">min</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>d</mi></mrow></msup 
></mrow></munder 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-punc" stretchy="false">:</mo><mo  
class="MathClass-rel" stretchy="false">=</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mi  
>n</mi></mrow></mfrac><munderover  accentunder="false" accent="false"><mrow   
><mo   
>∑</mo>
  </mrow><mrow  
><mi  
>i</mi><mo  
class="MathClass-rel" stretchy="false">=</mo><mn>1</mn></mrow><mrow  
><mi  
>n</mi></mrow></munderover 
><msub><mrow  
><mi  
>f</mi></mrow><mrow  
>
<mi  
>i</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 213--><p  class="indent" >   applying Newton’s method to the zero inclusion problem of the monotone gradient operator
yields the following update rule <table  class="equation-star"><tr><td>
<!--l. 214--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">[</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">]</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 217--><p  class="indent" >   which is also a solution to the quadratic approximation <table  class="equation-star"><tr><td>
<!--l. 218--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
             <mi  
>ϕ</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn></mrow></mfrac> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 222--><p  class="indent" >   A classical extension is the cubic-regularized Newton Method weighting by
<!--l. 222--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>r</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow></math> a
regularization term <table  class="equation-star"><tr><td>
<!--l. 223--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                     <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">[</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>L</mi></mrow><mrow  
>
<mn>2</mn></mrow></msub 
><msup><mrow  
><mi  
>r</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">]</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 227--><p  class="indent" >   Choosing the right method depends crucially on the amount of data used and their
dimensionality (i.e., on the parameters <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>n</mi></mrow></math>
and <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi></mrow></math>).
Newton Methods are important in the regime of intermediate <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi></mrow></math>
and <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>n</mi></mrow></math>.
Approximative methods are important where evaluating the whole Hessian <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>O</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>n</mi><msup><mrow  
><mi  
>p</mi></mrow><mrow  
><mn>2</mn></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
and evaluating its (pseudo-)inverse <!--l. 227--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>O</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>p</mi></mrow><mrow  
><mn>3</mn></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
is infeasible.
<!--l. 229--><p  class="indent" >   <a  
 id="refsection:34"></a><a  
 id="x1-60r18"></a>
   <div  class="newtheorem">
<!--l. 229--><p  class="noindent" ><span  class="head">
<a  
 id="pd12rq4h"></a>
<span  
class="cmbx-10">Definition – </span>Approximate Newton Methods<br  
class="newline" /> </span><a  
 id="x1-62"></a><a  
 id="pd12rq4h"></a>Methods constructing approximation of the Hessian at a
point <!--l. 230--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
satisfying the inequality <table  class="equation-star"><tr><td>
<!--l. 231--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                   <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>𝜖</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mi  
>H</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">≼</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">≼</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mi  
>𝜖</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mi  
>H</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mspace  width="1em" class="quad"/><mstyle  
class="text"><mtext   >with</mtext></mstyle><mspace  width="1em" class="quad"/><mi  
>𝜖</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mo  
class="MathClass-open" stretchy="false">[</mo><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 234--><p  class="indent" >   are called <span  
class="cmti-10">approximative newton methods</span>. They exhibit a <a  
href="#v_o4l6wn">linear-quadratic</a> rate of convergence
and include Hessian subsampling and sketching. <a  
 id="refsection:35"></a><a  
 id="x1-63r19"></a>
   <div  class="newtheorem">
<!--l. 235--><p  class="noindent" ><span  class="head">
<a  
 id="vx9hm059"></a>
<span  
class="cmbx-10">Beispiel – </span>NewSamp<br  
class="newline" /> </span><a  
 id="x1-65"></a><a  
 id="vx9hm059"></a>See [<a  
 id="x1-66"></a><a  
href="#cite.35@newsamp">EM15</a>]
          <dl  class="thebibliography"><dt  id="X35-newsamp" class="thebibliography">
[EM15]    </dt><dd  
id="bib-9" class="thebibliography">
          <!--l. 237--><p  class="noindent" ><a  
 id="cite.35@newsamp"></a>Murat A. Erdogdu and Andrea Montanari. “Convergence rates of sub-sampled
          Newton methods”. In: <span  
class="cmti-10">Advances in Neural Information Processing Systems 28:</span>
          <span  
class="cmti-10">Annual Conference on Neural Information Processing Systems 2015, December</span>
          <span  
class="cmti-10">7-12,  2015,  Montreal,  Quebec,  Canada</span>.  Ed.  by  Corinna  Cortes  et  al.  2015,
          pp. 3052–3060. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://proceedings.neurips.cc/paper/2015/hash/404dcc91b2aeaa7caa47487d1483e48a-Abstract.html" class="url" ><span  
class="cmtt-10">https://proceedings.neurips.cc/paper/2015/hash/404dcc91b2aeaa7caa47487d1483e48a-Abstract.html</span></a>.</dd></dl>
                                                                            
                                                                            
<!--l. 237--><p  class="indent" >   <a  
 id="refsection:36"></a></div>
<!--l. 237--><p  class="indent" >
<!--l. 239--><p  class="indent" >   <a  
 id="refsection:37"></a><a  
 id="x1-67r20"></a>
   <div  class="newtheorem">
<!--l. 239--><p  class="noindent" ><span  class="head">
<a  
 id="zcwoa_s7"></a>
<span  
class="cmbx-10">Literature – </span>Unified Analysis Framework<br  
class="newline" /> </span><a  
 id="x1-69"></a><a  
 id="zcwoa_s7"></a>See [<a  
 id="x1-70"></a><a  
href="#cite.37@approximate_newton_method">YLZ21</a>] for a unifying framework of global
and local convergence behaviour. Also see [<a  
 id="x1-71"></a><a  
href="#cite.37@unified_convergence_cubic_newton">CDJ23</a>] for analysis of Cubic Newton Method.
A short overview can be found at [<a  
 id="x1-72"></a><a  
href="#cite.37@approximate_newton_liu">Liu23</a>].
          <dl  class="thebibliography"><dt  id="X37-unified_convergence_cubic_newton" class="thebibliography">
[CDJ23]   </dt><dd  
id="bib-10" class="thebibliography">
          <!--l. 241--><p  class="noindent" ><a  
 id="cite.37@unified_convergence_cubic_newton"></a>El  Mahdi  Chayti,  Nikita  Doikov,  and  Martin  Jaggi.  “Unified  Convergence
          Theory of Stochastic and Variance-Reduced Cubic Newton Methods”. In: <span  
class="cmti-10">CoRR</span>
          abs/2302.11962 (2023). <span  
class="cmcsc-10"><span  
class="small-caps">d</span><span  
class="small-caps">o</span><span  
class="small-caps">i</span></span>: <a  
href="https://doi.org/10.48550/ARXIV.2302.11962" ><span  
class="cmtt-10">10.48550/ARXIV.2302.11962</span></a>. arXiv: <a  
href="https://arxiv.org/abs/2302.11962" ><span  
class="cmtt-10">2302.11962</span></a>.
          <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://doi.org/10.48550/arXiv.2302.11962" class="url" ><span  
class="cmtt-10">https://doi.org/10.48550/arXiv.2302.11962</span></a>.
          </dd><dt  id="X37-approximate_newton_liu" class="thebibliography">
[Liu23]    </dt><dd  
id="bib-11" class="thebibliography">
          <!--l. 241--><p  class="noindent" ><a  
 id="cite.37@approximate_newton_liu"></a>Chengchang  Liu.  <span  
class="cmti-10">A  Note  for  Approximate  Second-order  Methods</span>.  [Online;
          accessed 19. Dec. 2023]. Dec. 2023. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://github.com/7CCLiu/7CCLiu.github.io/blob/82c48aafacea01bb432a8d0b789ecf65130a4817/Note_approximate_Newton.pdf" class="url" ><span  
class="cmtt-10">https://github.com/7CCLiu/7CCLiu.github.io/blob/82c48aafacea01bb432a8d0b789ecf65130a4817/Note_approximate_Newton.pdf</span></a>.
          </dd><dt  id="X37-approximate_newton_method" class="thebibliography">
[YLZ21]   </dt><dd  
id="bib-12" class="thebibliography">
          <!--l. 241--><p  class="noindent" ><a  
 id="cite.37@approximate_newton_method"></a>Haishan Ye, Luo Luo, and Zhihua Zhang. “Approximate Newton Methods”. In:
          <span  
class="cmti-10">J.      Mach.      Learn.      Res.      </span>22       (2021),       66:1–66:41.       <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="http://jmlr.org/papers/v22/19-870.html" class="url" ><span  
class="cmtt-10">http://jmlr.org/papers/v22/19-870.html</span></a>.</dd></dl>
<!--l. 241--><p  class="indent" >   <a  
 id="refsection:38"></a></div>
<!--l. 241--><p  class="indent" >
<!--l. 242--><p  class="indent" >   <a  
 id="refsection:39"></a></div>
<!--l. 242--><p  class="indent" >
<!--l. 243--><p  class="indent" >   <a  
 id="refsection:40"></a></div>
<!--l. 243--><p  class="indent" >
    
</body> 
</html>
                                                                            


