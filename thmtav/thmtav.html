<!DOCTYPE html> 
<html  lang="en-US" xml:lang="en-US" > 
<head> <title>Theorem Tavern</title> 
<meta   charset="utf-8" /> 
<meta  name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta  name="viewport" content="width=device-width,initial-scale=1" /> 
<link  rel="stylesheet" type="text/css" href="thmtav.css" /> 
<meta  name="src" content="thmtav.tex"> 
</head><body  
>
<!--l. 52--><p  class="noindent" ><a  
 id="refsection:1"></a><a  
 id="x1-1doc"></a><a  
 id="x1-2r1"></a>
   <div  class="newtheorem">
<!--l. 52--><p  class="noindent" ><span  class="head">
<a  
 id="f6izn8iw"></a>
<span  
class="cmbx-10">Definition – </span>Proximal Operator<br  
class="newline" /> </span><a  
 id="x1-4"></a><a  
 id="f6izn8iw"></a>The  proximal  operator  (also  called  proximal  mapping),
also see resolvant for CCP case, is given by
   <table  class="equation-star"><tr><td>
<!--l. 55--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                <msub><mrow  
><mi  class="qopname">prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>λ</mi><mi  
>f</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> argmin</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>y</mi></mrow></munder 
> <mrow><mo  fence="true" form="prefix"> {</mo><mrow><mi  
>Θ</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-punc" stretchy="false">;</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>λ</mi><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
></mrow><mo  fence="true" form="postfix">}</mo></mrow>
</math></td></tr></table>
<!--l. 59--><p  class="indent" >   <a  
 id="refsection:2"></a><a  
 id="x1-5r2"></a>
   <div  class="newtheorem">
<!--l. 59--><p  class="noindent" ><span  class="head">
<a  
 id="78req5r7"></a>
<span  
class="cmbx-10">Satz – </span>Convergence with Lyapunov Analysis<br  
class="newline" /> </span><a  
 id="x1-7"></a><a  
 id="78req5r7"></a>Let
<!--l. 60--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>F</mi></mstyle></mrow><mrow  
><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>∞</mi></mrow></msub 
></mrow></math>. For any
<!--l. 60--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>k</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mi  
>ℕ</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math> and
any <!--l. 60--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
></mrow></math>,
the inequality
<!--tex4ht:inline--><!--l. 64--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable  
displaystyle="true" columnalign="left" class="alignat-star">
                     <mtr><mtd  
columnalign="right" class="align-odd"></mtd>                       <mtd  
class="align-even"><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-bin" stretchy="false">+</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mfrac><mrow  
><mn>1</mn></mrow>
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msub 
><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label">
                     <mspace  width="2em"/></mtd></mtr><mtr><mtd  
columnalign="right" class="align-odd"> <mo  
class="MathClass-rel" stretchy="false">≤</mo></mtd>                     <mtd  
class="align-even"><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mo  
class="MathClass-bin" stretchy="false">+</mo><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"><mfrac><mrow  
><mn>1</mn></mrow>
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mspace  width="2em"/></mtd>                       <mtd  
columnalign="right" class="align-odd"></mtd>                     <mtd  
class="align-even"> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
>
<mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label"><mspace  width="2em"/></mtd>                     <mtd  
columnalign="right" class="align-label"></mtd>                     <mtd  
class="align-label">
   <mspace  width="2em"/></mtd></mtr></mtable></math>
<!--l. 65--><p  class="noindent" >holds for iteration <!--l. 65--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mi  
>f</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
and number <!--l. 65--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msub><mrow  
><mi  
>A</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>k</mi></mrow></msub 
></mrow></math>.
<!--l. 66--><p  class="indent" >   <a  
 id="refsection:3"></a></div>
<!--l. 66--><p  class="indent" >
<!--l. 68--><p  class="indent" >   <a  
 id="refsection:4"></a><a  
 id="x1-8r3"></a>
   <div  class="newtheorem">
<!--l. 68--><p  class="noindent" ><span  class="head">
<a  
 id="hnns6j86"></a>
<span  
class="cmbx-10">Remark – </span>Computation complexity<br  
class="newline" /> </span><a  
 id="x1-10"></a><a  
 id="hnns6j86"></a><a  
href="#f6izn8iw">Proximal   operations</a>   are   in   general   expensive,
sometimes                                                                                                       as
expensive as minimizing the function itself. There are however many instances of function
<!--l. 71--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi></mrow></math>
for which an analytic solution exists. For composite problems, those parts are isolated and
solved separately by a conceptional proximal operator.
<!--l. 74--><p  class="indent" >   <a  
 id="refsection:5"></a></div>
<!--l. 74--><p  class="indent" >
<!--l. 76--><p  class="indent" >   <a  
 id="refsection:6"></a><a  
 id="x1-11r4"></a>
   <div  class="newtheorem">
<!--l. 76--><p  class="noindent" ><span  class="head">
<a  
 id="sbkmp32j"></a>
<span  
class="cmbx-10">Remark – </span>Differentials of Proximals<br  
class="newline" /> </span><a  
 id="x1-13"></a><a  
 id="sbkmp32j"></a>The differential of a proximal operator with respect to its scaling
factor <!--l. 78--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>λ</mi></mrow></math>
is given by <table  class="equation-star"><tr><td>
<!--l. 79--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                 <mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow  
><mi  class="qopname">prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>λ</mi><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">[</mo><mi  
>λ</mi><mi  class="qopname">H</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo><mi  class="qopname"> Id</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo  
class="MathClass-close" stretchy="false">]</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
><mi  class="qopname"> d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-punc" stretchy="false">,</mo><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>λ</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 84--><p  class="indent" >   This result illustrates the smoothing effect of Moreau envelope for non-smooth functions
(or              functions              under              bad              conditions).              When
<!--l. 86--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>λ</mi> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mn>0</mn></mrow></math>
we limit at equivalence to the Jacobian at optimal point.
<!--l. 88--><p  class="indent" >   This  is  a  special  case  of  bi-level  optimization,  see  [<a  
 id="x1-14"></a>  <a  
href="#cite.6@bilevel_diff">Gou+16</a>,   <a  
href="http://rfsantacruz.github.io/files/pdfs/TR2016_argmin.pdf#lemma.3.2" >Lemma  3.2</a>  ]  with
<!--l. 89--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>λ</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>λ</mi><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>u</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
></mrow></math>
          <dl  class="thebibliography"><dt  id="X6-bilevel_diff" class="thebibliography">
[Gou+16]  </dt><dd  
id="bib-1" class="thebibliography">
          <!--l. 90--><p  class="noindent" ><a  
 id="cite.6@bilevel_diff"></a>Stephen Gould et al. “On Differentiating Parameterized Argmin and Argmax
          Problems                       with                       Application                       to
          Bi-level Optimization”. In: <span  
class="cmti-10">CoRR </span>abs/1607.05447 (2016). arXiv: <a  
href="https://arxiv.org/abs/1607.05447" ><span  
class="cmtt-10">1607.05447</span></a>.
          <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="http://rfsantacruz.github.io/files/pdfs/TR2016_argmin.pdf" class="url" ><span  
class="cmtt-10">http://rfsantacruz.github.io/files/pdfs/TR2016_argmin.pdf</span></a>.</dd></dl>
<!--l. 90--><p  class="indent" >   <a  
 id="refsection:7"></a></div>
<!--l. 90--><p  class="indent" >
<!--l. 91--><p  class="indent" >   <a  
 id="refsection:8"></a></div>
<!--l. 91--><p  class="indent" >   <a  
 id="refsection:9"></a><a  
 id="x1-12rdoc"></a><a  
 id="x1-15r5"></a>
   <div  class="newtheorem">
<!--l. 92--><p  class="noindent" ><span  class="head">
<a  
 id="g87jzem_"></a>
<span  
class="cmbx-10">Definition – </span>Closed Convex Proper<br  
class="newline" /> </span><a  
 id="x1-17"></a><a  
 id="g87jzem_"></a>A collective term for functions which are closed, convex
and proper. This family includes most function encountered in application and excludes
special cases found in analysis.
                                                                            
                                                                            
<!--l. 94--><p  class="indent" >   <a  
 id="refsection:10"></a></div>
<!--l. 94--><p  class="indent" >   <a  
 id="refsection:11"></a><a  
 id="x1-16rdoc"></a><a  
 id="x1-18r6"></a>
   <div  class="newtheorem">
<!--l. 95--><p  class="noindent" ><span  class="head">
<a  
 id="5nalj3hx"></a>
<span  
class="cmbx-10">Definition – </span>Lipschitz Regularity<br  
class="newline" /> </span><a  
 id="x1-20"></a><a  
 id="5nalj3hx"></a>For <!--l. 96--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math>,
we say that a mapping <!--l. 96--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-punc" stretchy="false">:</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">→</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>m</mi></mrow></msup 
></mrow></math>
is L-Lipschitz if globally <table  class="equation-star"><tr><td>
<!--l. 97--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                      <mo  
class="MathClass-rel" stretchy="false">∥</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mspace  width="2em" class="qquad"/><mi  
class="MathClass-op">∀</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>x</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>y</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 100--><p  class="indent" >   If a mapping is Lipschitz, it is a continuous mapping because for every <!--l. 101--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>δ</mi></mrow></math>
exists <!--l. 101--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>𝜖</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>L</mi><mi  
>δ</mi></mrow></math>.
The composition of <!--l. 101--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
></mrow></math>
and <!--l. 101--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
<!--l. 102--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">∘</mo><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
is <!--l. 102--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>-Lipschitz
(<span  
class="cmti-10">hint </span>apply Lipschitz inequality twice). The sum of two mappings, <!--l. 103--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><msub><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>
is <!--l. 103--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>L</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>-Lipschitz.
<!--l. 105--><p  class="indent" >   <a  
 id="refsection:12"></a><a  
 id="x1-21r7"></a>
   <div  class="newtheorem">
<!--l. 105--><p  class="noindent" ><span  class="head">
<a  
 id="17vzrkyq"></a>
<span  
class="cmbx-10">Beispiel – </span>Affine Function<br  
class="newline" /> </span><a  
 id="x1-23"></a><a  
 id="17vzrkyq"></a>An affine function <!--l. 106--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>F</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>A</mi><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mi  
>b</mi></mrow></math>
has Lipschitz constant <!--l. 106--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>A</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>,
the spectral norm or maximum singular value of <!--l. 107--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>A</mi></mrow></math>.
<!--l. 108--><p  class="indent" >   <a  
 id="refsection:13"></a></div>
<!--l. 108--><p  class="indent" >
<!--l. 110--><p  class="indent" >   <a  
 id="refsection:14"></a><a  
 id="x1-24r8"></a>
   <div  class="newtheorem">
<!--l. 110--><p  class="noindent" ><span  class="head">
<a  
 id="jydhwyqa"></a>
<span  
class="cmbx-10">Beispiel – </span>Differentiable Function<br  
class="newline" /> </span><a  
 id="x1-26"></a><a  
 id="jydhwyqa"></a>Let <!--l. 111--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-punc" stretchy="false">:</mo><msup><mrow  
> <mstyle  
mathvariant="script"><mi  
>R</mi></mstyle></mrow><mrow  
><mi  
>n</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">→</mo><msup><mrow  
><mstyle  
mathvariant="script"><mi  
>R</mi></mstyle></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>
be a differentiable function, then <table  class="equation-star"><tr><td>
<!--l. 112--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                          <mstyle  
class="text"><mtext   >L-Lipschitz</mtext></mstyle><mspace  width="1em" class="quad"/> <mo  
class="MathClass-rel" stretchy="false">↔</mo><mspace  width="1em" class="quad"/><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  class="qopname">D</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi>
</math></td></tr></table>
   <div  class="tabular"> <table  id="TBL-1" class="tabular" 
 
><colgroup  id="TBL-1-1g"><col  
id="TBL-1-1"><col  
id="TBL-1-2"></colgroup><tr   
 style="vertical-align:baseline;" id="TBL-1-1-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-1-1"  
class="td11">For a proof</td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-1-2"  
class="td11">(<!--l. 117--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mspace  width="0.28em" class="thickpace"/><mo  
class="MathClass-rel" stretchy="false">⟹</mo><mspace  width="0.28em" class="thickpace"/></mrow></math>) bound definition of differentials                                        </td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-2-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-2-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-2-2"  
class="td11">(<!--l. 118--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mspace  width="0.28em" class="thickpace"/><mo  
class="MathClass-rel" stretchy="false">⟸</mo><mspace  width="0.28em" class="thickpace"/></mrow></math>) apply mean value theorem and Cauchy-Schwartz inequality to</td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-3-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-3-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-3-2"  
class="td11">  <!--l. 120--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>                                                                                  </td>
</tr><tr   
 style="vertical-align:baseline;" id="TBL-1-4-"><td   style="text-align:right; white-space:nowrap;" id="TBL-1-4-1"  
class="td11">          </td><td   style="text-align:left; white-space:nowrap;" id="TBL-1-4-2"  
class="td11">  (with <!--l. 121--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><mstyle  
mathvariant="script"><mi  
>T</mi></mstyle><mi  
>y</mi><msubsup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow><mrow  
><mn>2</mn></mrow></msubsup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>g</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mn>0</mn><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>)                                                                         </td> </tr></table></div>
<!--l. 123--><p  class="indent" >   <a  
 id="refsection:15"></a></div>
<!--l. 123--><p  class="indent" >
<!--l. 125--><p  class="indent" >   <a  
 id="refsection:16"></a><a  
 id="x1-27r9"></a>
   <div  class="newtheorem">
<!--l. 125--><p  class="noindent" ><span  class="head">
<a  
 id="5pxh2ufj"></a>
<span  
class="cmbx-10">Beispiel – </span>Projections<br  
class="newline" /> </span><a  
 id="x1-29"></a><a  
 id="5pxh2ufj"></a>The projection of <!--l. 126--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
onto a non-empty closed convex set <!--l. 126--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></math>
is defined as <table  class="equation-star"><tr><td>
<!--l. 128--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                   <msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> argmin</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></munder 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>z</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> prox</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  class="qopname">I</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 132--><p  class="indent" >   and a <a  
href="#2s6tfa1j">non-expansive</a> operator with unique closest point in <!--l. 133--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></math>.
<!--l. 135--><p  class="indent" >   For a proof see that the closest projection of <!--l. 135--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
is a fixed-point <!--l. 136--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>
and the differential <!--l. 137--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></msub 
><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-rel" stretchy="false">=</mo><msub><mrow  
><mi  class="qopname"> d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"> dist</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>.
Apply the optimality condition
<!--l. 142--><p  class="indent" >
<!--tex4ht:inline--><!--l. 145--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" ><mtable  
displaystyle="true" columnalign="left" class="alignat-star">
                            <mtr><mtd  
columnalign="right" class="align-odd"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  class="qopname">D</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
></mtd>                            <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                               <mtd  
columnalign="right" class="align-odd"></mtd>                            <mtd  
class="align-even"> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mn>0</mn><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label"><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label">
                            <mspace  width="2em"/></mtd></mtr><mtr><mtd  
columnalign="right" class="align-odd"><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>u</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mi  
>T</mi></mrow></msup 
></mtd>                            <mtd  
class="align-even"><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script">
<mi  
>C</mi></mstyle></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>u</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-odd"></mtd>                            <mtd  
class="align-even"> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mn>0</mn><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label"><mspace  width="2em"/></mtd>                            <mtd  
columnalign="right" class="align-label"></mtd>                            <mtd  
class="align-label">
   <mspace  width="2em"/></mtd></mtr></mtable></math>
at two points <!--l. 146--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>y</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>.
Adding both, apply Cauchy-Schwartz inequality to conclude <table  class="equation-star"><tr><td>
                                                                            
                                                                            
<!--l. 148--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                           <mo  
class="MathClass-rel" stretchy="false">∥</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo><msub><mrow  
><mi  class="qopname"><mi  mathvariant="normal">Π</mi></mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--></mrow><mrow  
><mstyle  
mathvariant="script"><mi  
>C</mi></mstyle></mrow></msub 
><mi  
>y</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">≤</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><msub><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msub 
><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
   <a  
 id="refsection:17"></a></div>
<!--l. 152--><p  class="indent" >
<!--l. 154--><p  class="indent" >   <a  
 id="refsection:18"></a><a  
 id="x1-30r10"></a>
   <div  class="newtheorem">
<!--l. 154--><p  class="noindent" ><span  class="head">
<a  
 id="2s6tfa1j"></a>
<span  
class="cmbx-10">Remark – </span>Nonexpansive and Contractive Mappings<br  
class="newline" /> </span><a  
 id="x1-32"></a><a  
 id="2s6tfa1j"></a>A mapping is called nonexpansive for
<!--l. 155--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mn>1</mn></mrow></math>,
contractive for <!--l. 156--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>.
<!--l. 157--><p  class="indent" >   <a  
 id="refsection:19"></a></div>
<!--l. 157--><p  class="indent" >
<!--l. 158--><p  class="indent" >   <a  
 id="refsection:20"></a></div>
<!--l. 158--><p  class="indent" >   <a  
 id="refsection:21"></a><a  
 id="x1-31rdoc"></a><a  
 id="x1-33r11"></a>
   <div  class="newtheorem">
<!--l. 159--><p  class="noindent" ><span  class="head">
<a  
 id="ceh4aors"></a>
<span  
class="cmbx-10">Definition – </span>L-Smooth (<span  
class="cmti-10">o</span>r L-Lipschitz Continuous Gradient)<br  
class="newline" /> </span><a  
 id="x1-35"></a><a  
 id="ceh4aors"></a>Lipschitz regularity for the gradient
of a function is called a L-Lipschitz continuous gradient (or L-smooth) function with
<!--l. 161--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>L</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn></mrow></math>
<table  class="equation-star"><tr><td>
<!--l. 162--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                         <mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>L</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>y</mi><mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 166--><p  class="indent" >   <a  
 id="refsection:22"></a><a  
 id="x1-36r12"></a>
   <div  class="newtheorem">
<!--l. 166--><p  class="noindent" ><span  class="head">
<a  
 id="5vsiv5i2"></a>
<span  
class="cmbx-10">Remark – </span>Cocoerciveness of L-Smooth functions<br  
class="newline" /> </span><a  
 id="x1-38"></a><a  
 id="5vsiv5i2"></a>For  a  convex  function  (L-Smootheness
<!--l. 167--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-rel" stretchy="false">⟺</mo></mrow></math>
1/L-cocoerciveness of gradients).
<!--l. 170--><p  class="indent" >   <span  
class="cmti-10">Proof sketch </span>Use inequality <!--l. 170--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>y</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn><mi  
>L</mi></mrow></mfrac><mo  
class="MathClass-rel" stretchy="false">∥</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msup 
></mrow></math>
(which is implied by L-smootheness when function convex). Evaluate function at two points
<table  class="equation-star"><tr><td>
<!--l. 174--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                <msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>x</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>z</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow><mspace  width="1em" class="quad"/><mstyle  
class="text"><mtext   >and</mtext></mstyle><mspace  width="1em" class="quad"/><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>y</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>z</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">−</mo><mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>y</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>z</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow>
</math></td></tr></table>
<!--l. 178--><p  class="indent" >   and
combine both inequalities to show co-coerciveness. This can also be seen from the relation
<!--l. 179--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>∂</mi><mi  
>f</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>∂</mi><msup><mrow  
><mi  
>f</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>
for CCP functions.
<!--l. 181--><p  class="indent" >   <a  
 id="refsection:23"></a></div>
<!--l. 181--><p  class="indent" >
<!--l. 183--><p  class="indent" >   <a  
 id="refsection:24"></a><a  
 id="x1-39r13"></a>
   <div  class="newtheorem">
<!--l. 183--><p  class="noindent" ><span  class="head">
<a  
 id="2tz2l_0t"></a>
<span  
class="cmbx-10">Literature –</span><br  
class="newline" /> </span><a  
 id="x1-41"></a><a  
 id="2tz2l_0t"></a>A good overview of continuous gradient under various conditions can be found
at the blog post [<a  
 id="x1-42"></a><a  
href="#cite.24@zhou_continuous_gradient">Zho</a>], also see [<a  
 id="x1-43"></a> <a  
href="#cite.24@acceleration_methods">dST21</a>,  <a  
href="https://arxiv.org/pdf/2101.09545.pdf#theorem.A.1.1" >Appendix A</a> ]. Further [<a  
 id="x1-44"></a> <a  
href="#cite.24@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#theorem.3.4" >connections</a> ] of
smoothness to [ <a  
href="#cite.24@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#equation.3.13" >expected-smoothness</a> ] and [ <a  
href="#cite.24@structured_nonconvex_functions">GSL21</a>,  <a  
href="https://arxiv.org/pdf/2006.10311.pdf#assumption.3.1" >expected residual</a> ] exist. Also
the [<a  
 id="x1-45"></a> <a  
href="#cite.24@garrigos2023handbook">GG23</a>,  <a  
href="https://arxiv.org/pdf/2301.11235.pdf#subsection.2.5" >Section 2.5</a> ] lists a number of compact proofs for smoothness and smoothness
under convexity.
          <dl  class="thebibliography"><dt  id="X24-acceleration_methods" class="thebibliography">
[dST21]   </dt><dd  
id="bib-2" class="thebibliography">
          <!--l. 186--><p  class="noindent" ><a  
 id="cite.24@acceleration_methods"></a>Alexandre d’Aspremont, Damien Scieur, and Adrien B. Taylor. “Acceleration
          Methods”.  In:  <span  
class="cmti-10">CoRR  </span>abs/2101.09545  (2021).  arXiv:  <a  
href="https://arxiv.org/abs/2101.09545" ><span  
class="cmtt-10">2101 . 09545</span></a>.  <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://arxiv.org/pdf/2101.09545.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2101.09545.pdf</span></a>.
          </dd><dt  id="X24-garrigos2023handbook" class="thebibliography">
[GG23]    </dt><dd  
id="bib-3" class="thebibliography">
          <!--l. 186--><p  class="noindent" ><a  
 id="cite.24@garrigos2023handbook"></a>Guillaume Garrigos and Robert M. Gower. <span  
class="cmti-10">Handbook of Convergence Theorems</span>
          <span  
class="cmti-10">for (Stochastic) Gradient Methods</span>. 2023. arXiv: <a  
href="https://arxiv.org/abs/2301.11235" ><span  
class="cmtt-10">2301.11235 [math.OC]</span></a>. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://arxiv.org/pdf/2301.11235.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2301.11235.pdf</span></a>.
          </dd><dt  id="X24-structured_nonconvex_functions" class="thebibliography">
[GSL21]   </dt><dd  
id="bib-4" class="thebibliography">
          <!--l. 186--><p  class="noindent" ><a  
 id="cite.24@structured_nonconvex_functions"></a>Robert M. Gower, Othmane Sebbouh, and Nicolas Loizou. “SGD for Structured
          Nonconvex Functions: Learning Rates, Minibatching and Interpolation”. In: <span  
class="cmti-10">The</span>
          <span  
class="cmti-10">24th International Conference on Artificial Intelligence and Statistics, AISTATS</span>
          <span  
class="cmti-10">2021, April 13-15, 2021, Virtual Event</span>. Ed. by Arindam Banerjee and Kenji
          Fukumizu. Vol. 130. Proceedings of Machine Learning Research. PMLR, 2021,
          pp. 1315–1323. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://arxiv.org/pdf/2006.10311.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2006.10311.pdf</span></a>.
          </dd><dt  id="X24-zhou_continuous_gradient" class="thebibliography">
[Zho]      </dt><dd  
id="bib-5" class="thebibliography">
          <!--l. 186--><p  class="noindent" ><a  
 id="cite.24@zhou_continuous_gradient"></a>Xingyu         Zhou.         <span  
class="cmti-10">Lipschitz        continuous        gradient</span>.         <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://xingyuzhou.org/blog/notes/Lipschitz-gradient" class="url" ><span  
class="cmtt-10">https://xingyuzhou.org/blog/notes/Lipschitz-gradient</span></a>.</dd></dl>
<!--l. 186--><p  class="indent" >   <a  
 id="refsection:25"></a></div>
<!--l. 186--><p  class="indent" >
                                                                            
                                                                            
<!--l. 187--><p  class="indent" >   <a  
 id="refsection:26"></a></div>
<!--l. 187--><p  class="indent" >   <a  
 id="refsection:27"></a><a  
 id="x1-40rdoc"></a><a  
 id="x1-46r14"></a>
   <div  class="newtheorem">
<!--l. 188--><p  class="noindent" ><span  class="head">
<a  
 id="3m5jm_az"></a>
<span  
class="cmbx-10">Definition – </span>Quasar Convex<br  
class="newline" /> </span><a  
 id="x1-48"></a><a  
 id="3m5jm_az"></a>Let <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>ζ</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">]</mo></mrow></math>
and <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">∈</mo><msup><mrow  
><mstyle  
mathvariant="script"><mi  
>X</mi></mstyle></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>. We
say that <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>f</mi></mrow></math>
<!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>ζ</mi></mrow></math>-quasar-convex
with respect to <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
></mrow></math>
if for all <!--l. 189--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msup 
></mrow></math>,
<table  class="equation-star"><tr><td>
<!--l. 190--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">≥</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mi  
>ζ</mi></mrow></mfrac> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">⋆</mo></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi></mrow><mo  fence="true" form="postfix">⟩</mo></mrow><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 194--><p  class="indent" >   <a  
 id="refsection:28"></a><a  
 id="x1-49r15"></a>
   <div  class="newtheorem">
<!--l. 194--><p  class="noindent" ><span  class="head">
<a  
 id="c9swuw97"></a>
<span  
class="cmbx-10">Literature –</span><br  
class="newline" /> </span><a  
 id="x1-51"></a><a  
 id="c9swuw97"></a>Convergence analysis of quasar-convex functions exists with [<a  
 id="x1-52"></a> <a  
href="#cite.28@structured_nonconvex_functions">GSL21</a>, <a  
href="https://arxiv.org/pdf/2006.10311.pdf#subsection.4.1" >constant
and decreasing</a> ] step-sizes. Evaluation of star-convexity for NMF can be found in [<a  
 id="x1-53"></a><a  
href="#cite.28@star_convexity_nmf">BGW20</a>].
For variance transfer under non-convexity see [<a  
 id="x1-54"></a> <a  
href="#cite.28@sgd_arbitrary_sampling">Qia+19</a>,  <a  
href="http://proceedings.mlr.press/v97/qian19b.html#example.2.2" >Example 2.2</a> ].
          <dl  class="thebibliography"><dt  id="X28-star_convexity_nmf" class="thebibliography">
[BGW20]  </dt><dd  
id="bib-6" class="thebibliography">
          <!--l. 196--><p  class="noindent" ><a  
 id="cite.28@star_convexity_nmf"></a>Johan                Bjorck,                Carla                Gomes,                and
          Kilian Weinberger. <span  
class="cmti-10">Star-Convexity in Non-Negative Matrix Factorization</span>. 2020.
          <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://openreview.net/pdf?id=BylKwnEYvS" class="url" ><span  
class="cmtt-10">https://openreview.net/pdf?id=BylKwnEYvS</span></a>.
          </dd><dt  id="X28-structured_nonconvex_functions" class="thebibliography">
[GSL21]   </dt><dd  
id="bib-7" class="thebibliography">
          <!--l. 196--><p  class="noindent" ><a  
 id="cite.28@structured_nonconvex_functions"></a>Robert M. Gower, Othmane Sebbouh, and Nicolas Loizou. “SGD for Structured
          Nonconvex Functions: Learning Rates, Minibatching and Interpolation”. In: <span  
class="cmti-10">The</span>
          <span  
class="cmti-10">24th International Conference on Artificial Intelligence and Statistics, AISTATS</span>
          <span  
class="cmti-10">2021, April 13-15, 2021, Virtual Event</span>. Ed. by Arindam Banerjee and Kenji
          Fukumizu. Vol. 130. Proceedings of Machine Learning Research. PMLR, 2021,
          pp. 1315–1323. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://arxiv.org/pdf/2006.10311.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/2006.10311.pdf</span></a>.
          </dd><dt  id="X28-sgd_arbitrary_sampling" class="thebibliography">
[Qia+19]  </dt><dd  
id="bib-8" class="thebibliography">
          <!--l. 196--><p  class="noindent" ><a  
 id="cite.28@sgd_arbitrary_sampling"></a>Xun  Qian  et  al.  “SGD  with  Arbitrary  Sampling:  General  Analysis  and
          Improved  Rates”.  In:  <span  
class="cmti-10">Proceedings  of  the  36th  International  Conference  on</span>
          <span  
class="cmti-10">Machine  Learning,  ICML  2019,  9-15  June  2019,  Long  Beach,  California,</span>
          <span  
class="cmti-10">USA</span>.  Ed.  by  Kamalika  Chaudhuri  and  Ruslan  Salakhutdinov.  Vol. 97.
          Proceedings of Machine Learning Research. PMLR, 2019, pp. 5200–5209. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="http://proceedings.mlr.press/v97/qian19b.html" class="url" ><span  
class="cmtt-10">http://proceedings.mlr.press/v97/qian19b.html</span></a>.</dd></dl>
<!--l. 196--><p  class="indent" >   <a  
 id="refsection:29"></a></div>
<!--l. 196--><p  class="indent" >
<!--l. 197--><p  class="indent" >   <a  
 id="refsection:30"></a></div>
<!--l. 197--><p  class="indent" >   <a  
 id="refsection:31"></a><a  
 id="x1-50rdoc"></a><a  
 id="x1-55r16"></a>
   <div  class="newtheorem">
<!--l. 198--><p  class="noindent" ><span  class="head">
<a  
 id="v_o4l6wn"></a>
<span  
class="cmbx-10">Definition – </span>Asymptotic Convergence Rates<br  
class="newline" /> </span><a  
 id="x1-57"></a><a  
 id="v_o4l6wn"></a>Notions of sub-linear, linear and super-linear
(esp.  quadratic)  convergence  rates  are  important  taxonomy  to  discuss  the  efficiency  of
optimization algorithms.
<!--l. 201--><p  class="indent" >   A sequence of vectors <!--l. 201--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo></mrow></math> is said
to converge to a limit point <!--l. 201--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>
     <ul  class="itemize1">
     <li  class="itemize">
     <!--l. 203--><p  class="noindent" ><span  
class="cmti-10">sub-linear </span>if for some <!--l. 203--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 203--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mi  
>p</mi></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>∞</mi></mrow></math>,
     each new correct digit takes approximately the same amount of total work already
     done for previous digits
     </li>
     <li  class="itemize">
     <!--l. 204--><p  class="noindent" ><span  
class="cmti-10">linearly </span>if for some <!--l. 204--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>ρ</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 204--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>1</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mi  
>ρ</mi></mrow></math>,
     each new correct digit takes the <span  
class="cmti-10">same amount </span>of time
     </li>
     <li  class="itemize">
     <!--l. 205--><p  class="noindent" ><span  
class="cmti-10">super-linear </span>if <!--l. 205--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>1</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mn>0</mn></mrow></math>
     </li>
     <li  class="itemize">
     <!--l. 206--><p  class="noindent" ><span  
class="cmti-10">quadratic </span>if for some <!--l. 206--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mi  
>ρ</mi> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     we have <!--l. 206--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mn>2</mn></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">→</mo> <mi  
>ρ</mi></mrow></math>,
     every iteration the correct number of digits approximately doubles
     </li>
     <li  class="itemize">
     <!--l. 207--><p  class="noindent" ><span  
class="cmti-10">linear-quadratic </span>if for some <!--l. 207--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <mn>1</mn></mrow></math>
     and <!--l. 207--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mn>0</mn> <mo  
class="MathClass-rel" stretchy="false">&#x003C;</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>2</mn></mrow></msub 
></mrow></math>
     the inequality holds: <table  class="equation-star"><tr><td>
     <!--l. 208--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                                <mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo>
  <mo  
class="MathClass-rel" stretchy="false">∥</mo><mo  
class="MathClass-rel" stretchy="false">≤</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>ρ</mi></mrow><mrow  
>
<mn>2</mn></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mn>2</mn></mrow></msup 
>
</math></td></tr></table>
     </li></ul>
                                                                            
                                                                            
<!--l. 212--><p  class="noindent" >where we define the rate of convergence as <table  class="equation-star"><tr><td>
<!--l. 213--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                      <msup><mrow  
><mi  
>Γ</mi></mrow><mrow  
><mi  
>p</mi></mrow></msup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mo  
class="MathClass-open" stretchy="false">{</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>t</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">}</mo><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo><munder  class="msub"><mrow  
><mi  class="qopname"> lim</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
>
<mi  
>t</mi><mo  
class="MathClass-rel" stretchy="false">→</mo><mi  
>∞</mi></mrow></munder 
><mi  class="qopname">sup</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo> <mfrac><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow> 
<mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo><msup><mrow  
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow><mrow  
><mi  
>p</mi></mrow></msup 
></mrow></mfrac> <mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 217--><p  class="indent" >   Clearly quadratic convergence is an instance of super-linear convergence.
<!--l. 219--><p  class="indent" >   <a  
 id="refsection:32"></a><a  
 id="x1-58r17"></a>
   <div  class="newtheorem">
<!--l. 219--><p  class="noindent" ><span  class="head">
<a  
 id="ok2t_031"></a>
<span  
class="cmbx-10">Beispiel – </span>Sublinear Convergence in First-Order Methods<br  
class="newline" /> </span><a  
 id="x1-60"></a><a  
 id="ok2t_031"></a>Asymptotic  rates  discusses  the
case when <!--l. 220--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>t</mi></mrow></msup 
></mrow></math>
approaches <!--l. 220--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi><mo  
class="MathClass-bin" stretchy="false">∙</mo></mrow></math>.
For many first-order methods, this is not really relevant, as only a small number of iterations
are possible [<a  
 id="x1-61"></a><a  
href="#cite.32@sublinear_rate">Bor23</a>].
          <dl  class="thebibliography"><dt  id="X32-sublinear_rate" class="thebibliography">
[Bor23]    </dt><dd  
id="bib-9" class="thebibliography">
          <!--l. 221--><p  class="noindent" ><a  
 id="cite.32@sublinear_rate"></a>Brian          Borchers.          <span  
class="cmti-10">Sublinear         rate         of         convergence</span>
          <span  
class="cmti-10">in mathematical optimization</span>. [Online; accessed 19. Dec. 2023]. Dec. 2023. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>:
          <a  
href="https://math.stackexchange.com/a/2615629" class="url" ><span  
class="cmtt-10">https://math.stackexchange.com/a/2615629</span></a>.</dd></dl>
<!--l. 221--><p  class="indent" >   <a  
 id="refsection:33"></a></div>
<!--l. 221--><p  class="indent" >
   <a  
 id="refsection:34"></a></div>
<!--l. 223--><p  class="indent" >   <a  
 id="refsection:35"></a><a  
 id="x1-59rdoc"></a><a  
 id="x1-62r18"></a>
   <div  class="newtheorem">
<!--l. 224--><p  class="noindent" ><span  class="head">
<a  
 id="h9xvj58r"></a>
<span  
class="cmbx-10">Definition – </span>Newton Method<br  
class="newline" /> </span><a  
 id="x1-64"></a><a  
 id="h9xvj58r"></a>Consider the finite-sum minimization problem <table  class="equation-star"><tr><td>
<!--l. 226--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <munder  class="msub"><mrow  
><mi  class="qopname">min</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo></mrow><mrow  
><mi  
>x</mi><mo  
class="MathClass-rel" stretchy="false">∈</mo><msup><mrow  
><mi  
>ℝ</mi></mrow><mrow  
><mi  
>d</mi></mrow></msup 
></mrow></munder 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-punc" stretchy="false">:</mo><mo  
class="MathClass-rel" stretchy="false">=</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mi  
>n</mi></mrow></mfrac><munderover  accentunder="false" accent="false"><mrow   
><mo   
>∑</mo>
  </mrow><mrow  
><mi  
>i</mi><mo  
class="MathClass-rel" stretchy="false">=</mo><mn>1</mn></mrow><mrow  
><mi  
>n</mi></mrow></munderover 
><msub><mrow  
><mi  
>f</mi></mrow><mrow  
>
<mi  
>i</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 229--><p  class="indent" >   applying Newton’s method to the zero inclusion problem of the monotone gradient operator
yields the following update rule <table  class="equation-star"><tr><td>
<!--l. 230--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                        <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">[</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-close" stretchy="false">]</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 233--><p  class="indent" >   which is also a solution to the quadratic approximation <table  class="equation-star"><tr><td>
<!--l. 234--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
             <mi  
>ϕ</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mfrac><mrow  
><mn>1</mn></mrow> 
<mrow  
><mn>2</mn></mrow></mfrac> <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-rel" stretchy="false">|</mo><mi  
>x</mi> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 238--><p  class="indent" >   A classical extension is the cubic-regularized Newton Method weighting by
<!--l. 238--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msup><mrow  
><mi  
>r</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mo  
class="MathClass-rel" stretchy="false">∥</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-rel" stretchy="false">∥</mo></mrow></math> a
regularization term <table  class="equation-star"><tr><td>
<!--l. 239--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                     <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi><mo  
class="MathClass-bin" stretchy="false">+</mo><mn>1</mn></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-bin" stretchy="false">−</mo> <msup><mrow  
><mo  
class="MathClass-open" stretchy="false">[</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>L</mi></mrow><mrow  
>
<mn>2</mn></mrow></msub 
><msup><mrow  
><mi  
>r</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">]</mo></mrow><mrow  
><mo  
class="MathClass-bin" stretchy="false">−</mo><mn>1</mn></mrow></msup 
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>x</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 243--><p  class="indent" >   Choosing the right method depends crucially on the amount of data used and their
dimensionality (i.e., on the parameters <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>n</mi></mrow></math>
and <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi></mrow></math>).
Newton Methods are important in the regime of intermediate <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>p</mi></mrow></math>
and <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>n</mi></mrow></math>.
Approximative methods are important where evaluating the whole Hessian <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>O</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>n</mi><msup><mrow  
><mi  
>p</mi></mrow><mrow  
><mn>2</mn></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
and evaluating its (pseudo-)inverse <!--l. 243--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mstyle  
mathvariant="script"><mi  
>O</mi></mstyle><mo  
class="MathClass-open" stretchy="false">(</mo><msup><mrow  
><mi  
>p</mi></mrow><mrow  
><mn>3</mn></mrow></msup 
><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
is infeasible.
<!--l. 245--><p  class="indent" >   <a  
 id="refsection:36"></a><a  
 id="x1-65r19"></a>
   <div  class="newtheorem">
<!--l. 245--><p  class="noindent" ><span  class="head">
<a  
 id="pd12rq4h"></a>
                                                                            
                                                                            
<span  
class="cmbx-10">Definition – </span>Approximate Newton Methods<br  
class="newline" /> </span><a  
 id="x1-67"></a><a  
 id="pd12rq4h"></a>Methods constructing approximation of the Hessian at a
point <!--l. 246--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>x</mi></mrow></math>
satisfying the inequality <table  class="equation-star"><tr><td>
<!--l. 247--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                   <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">−</mo> <mi  
>𝜖</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mi  
>H</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
> <mo  
class="MathClass-rel" stretchy="false">≼</mo><msup><mrow  
><mi  
class="MathClass-op">∇</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo></mrow><mrow  
><mn>2</mn></mrow></msup 
><mi  
>f</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">≼</mo> <mo  
class="MathClass-open" stretchy="false">(</mo><mn>1</mn> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mi  
>𝜖</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msup><mrow  
><mi  
>H</mi></mrow><mrow  
><mi  
>k</mi></mrow></msup 
><mspace  width="1em" class="quad"/><mstyle  
class="text"><mtext   >with</mtext></mstyle><mspace  width="1em" class="quad"/><mi  
>𝜖</mi> <mo  
class="MathClass-rel" stretchy="false">∈</mo> <mo  
class="MathClass-open" stretchy="false">[</mo><mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>1</mn><mo  
class="MathClass-close" stretchy="false">)</mo>
</math></td></tr></table>
<!--l. 250--><p  class="indent" >   are called <span  
class="cmti-10">approximative newton methods</span>. They exhibit a <a  
href="#v_o4l6wn">linear-quadratic</a> rate of convergence
and include Hessian subsampling and sketching. <a  
 id="refsection:37"></a><a  
 id="x1-68r20"></a>
   <div  class="newtheorem">
<!--l. 251--><p  class="noindent" ><span  class="head">
<a  
 id="vx9hm059"></a>
<span  
class="cmbx-10">Beispiel – </span>NewSamp<br  
class="newline" /> </span><a  
 id="x1-70"></a><a  
 id="vx9hm059"></a>See [<a  
 id="x1-71"></a><a  
href="#cite.37@newsamp">EM15</a>]
          <dl  class="thebibliography"><dt  id="X37-newsamp" class="thebibliography">
[EM15]    </dt><dd  
id="bib-10" class="thebibliography">
          <!--l. 253--><p  class="noindent" ><a  
 id="cite.37@newsamp"></a>Murat A. Erdogdu and Andrea Montanari. “Convergence rates of sub-sampled
          Newton methods”. In: <span  
class="cmti-10">Advances in Neural Information Processing Systems 28:</span>
          <span  
class="cmti-10">Annual Conference on Neural Information Processing Systems 2015, December</span>
          <span  
class="cmti-10">7-12,  2015,  Montreal,  Quebec,  Canada</span>.  Ed.  by  Corinna  Cortes  et  al.  2015,
          pp. 3052–3060. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://proceedings.neurips.cc/paper/2015/hash/404dcc91b2aeaa7caa47487d1483e48a-Abstract.html" class="url" ><span  
class="cmtt-10">https://proceedings.neurips.cc/paper/2015/hash/404dcc91b2aeaa7caa47487d1483e48a-Abstract.html</span></a>.</dd></dl>
<!--l. 253--><p  class="indent" >   <a  
 id="refsection:38"></a></div>
<!--l. 253--><p  class="indent" >
<!--l. 255--><p  class="indent" >   <a  
 id="refsection:39"></a><a  
 id="x1-72r21"></a>
   <div  class="newtheorem">
<!--l. 255--><p  class="noindent" ><span  class="head">
<a  
 id="zcwoa_s7"></a>
<span  
class="cmbx-10">Literature – </span>Unified Analysis Framework<br  
class="newline" /> </span><a  
 id="x1-74"></a><a  
 id="zcwoa_s7"></a>See [<a  
 id="x1-75"></a><a  
href="#cite.39@approximate_newton_method">YLZ21</a>] for a unifying framework of global
and local convergence behaviour. Also see [<a  
 id="x1-76"></a><a  
href="#cite.39@unified_convergence_cubic_newton">CDJ23</a>] for analysis of Cubic Newton Method.
A short overview can be found at [<a  
 id="x1-77"></a><a  
href="#cite.39@approximate_newton_liu">Liu23</a>].
          <dl  class="thebibliography"><dt  id="X39-unified_convergence_cubic_newton" class="thebibliography">
[CDJ23]   </dt><dd  
id="bib-11" class="thebibliography">
          <!--l. 257--><p  class="noindent" ><a  
 id="cite.39@unified_convergence_cubic_newton"></a>El  Mahdi  Chayti,  Nikita  Doikov,  and  Martin  Jaggi.  “Unified  Convergence
          Theory of Stochastic and Variance-Reduced Cubic Newton Methods”. In: <span  
class="cmti-10">CoRR</span>
          abs/2302.11962 (2023). <span  
class="cmcsc-10"><span  
class="small-caps">d</span><span  
class="small-caps">o</span><span  
class="small-caps">i</span></span>: <a  
href="https://doi.org/10.48550/ARXIV.2302.11962" ><span  
class="cmtt-10">10.48550/ARXIV.2302.11962</span></a>. arXiv: <a  
href="https://arxiv.org/abs/2302.11962" ><span  
class="cmtt-10">2302.11962</span></a>.
          <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://doi.org/10.48550/arXiv.2302.11962" class="url" ><span  
class="cmtt-10">https://doi.org/10.48550/arXiv.2302.11962</span></a>.
          </dd><dt  id="X39-approximate_newton_liu" class="thebibliography">
[Liu23]    </dt><dd  
id="bib-12" class="thebibliography">
          <!--l. 257--><p  class="noindent" ><a  
 id="cite.39@approximate_newton_liu"></a>Chengchang  Liu.  <span  
class="cmti-10">A  Note  for  Approximate  Second-order  Methods</span>.  [Online;
          accessed 19. Dec. 2023]. Dec. 2023. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://github.com/7CCLiu/7CCLiu.github.io/blob/82c48aafacea01bb432a8d0b789ecf65130a4817/Note_approximate_Newton.pdf" class="url" ><span  
class="cmtt-10">https://github.com/7CCLiu/7CCLiu.github.io/blob/82c48aafacea01bb432a8d0b789ecf65130a4817/Note_approximate_Newton.pdf</span></a>.
          </dd><dt  id="X39-approximate_newton_method" class="thebibliography">
[YLZ21]   </dt><dd  
id="bib-13" class="thebibliography">
          <!--l. 257--><p  class="noindent" ><a  
 id="cite.39@approximate_newton_method"></a>Haishan                          Ye,                          Luo                          Luo,
          and Zhihua Zhang. “Approximate Newton Methods”. In: <span  
class="cmti-10">J. Mach. Learn. Res.</span>
          22 (2021), 66:1–66:41. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="http://jmlr.org/papers/v22/19-870.html" class="url" ><span  
class="cmtt-10">http://jmlr.org/papers/v22/19-870.html</span></a>.</dd></dl>
<!--l. 257--><p  class="indent" >   <a  
 id="refsection:40"></a></div>
<!--l. 257--><p  class="indent" >
<!--l. 258--><p  class="indent" >   <a  
 id="refsection:41"></a></div>
<!--l. 258--><p  class="indent" >
<!--l. 259--><p  class="indent" >   <a  
 id="refsection:42"></a></div>
<!--l. 259--><p  class="indent" >   <a  
 id="refsection:43"></a><a  
 id="x1-73rdoc"></a><a  
 id="x1-78r22"></a>
   <div  class="newtheorem">
<!--l. 260--><p  class="noindent" ><span  class="head">
<a  
 id="18x0c7vo"></a>
<span  
class="cmbx-10">Definition – </span>Orthogonal Polynomials<br  
class="newline" /> </span><a  
 id="x1-80"></a><a  
 id="18x0c7vo"></a>An        orthonormal        set        of        functions
<!--l. 261--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mn>0</mn></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mn>1</mn></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>…</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
with
<!--l. 262--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>n</mi></mrow></math>
finite or infinite, is characterized by the relations
   <table  class="equation-star"><tr><td>
<!--l. 265--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
                     <mrow><mo  fence="true" form="prefix"> ⟨</mo><mrow><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-rel" stretchy="false">|</mo><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>m</mi></mrow></msub 
></mrow><mo  fence="true" form="postfix">⟩</mo></mrow> <mo  
class="MathClass-rel" stretchy="false">=</mo><msubsup><mrow  
><mo   
> ∫
 <!--nolimits--></mo><!--nolimits--></mrow><mrow  
><mi  
>a</mi></mrow><mrow  
><mi  
>b</mi></mrow></msubsup 
><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
>
<mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>m</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mi  class="qopname">d</mi><mo> ⁡<!--FUNCTION APPLICATION--> </mo><!--nolimits--><mi  
>α</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msub><mrow  
><mi  
>δ</mi></mrow><mrow  
><mi  
>n</mi><mi  
>m</mi></mrow></msub 
>
</math></td></tr></table>
<!--l. 270--><p  class="indent" >   If the support <!--l. 270--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>τ</mi><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
only has a finite number <!--l. 270--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>N</mi></mrow></math>
of points of increase, <!--l. 271--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>l</mi></mrow></math>
is necessary finite and <!--l. 271--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><mi  
>l</mi> <mo  
class="MathClass-rel" stretchy="false">≤</mo> <mi  
>N</mi></mrow></math>.
Furthermore functions of this kind are necessarily linearly independent.
<!--l. 274--><p  class="indent" >   <a  
 id="refsection:44"></a><a  
 id="x1-81r23"></a>
   <div  class="newtheorem">
<!--l. 274--><p  class="noindent" ><span  class="head">
<a  
 id="g__9ue2i"></a>
<span  
class="cmbx-10">Satz – </span>Reparametrization<br  
class="newline" /> </span><a  
 id="x1-83"></a><a  
 id="g__9ue2i"></a>Let         the         set         of         real-valued         functions
<!--l. 275--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mn>0</mn></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>…</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
be                                                      of                                                      class
<!--l. 276--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msubsup><mrow  
><mi  
>𝕃</mi></mrow><mrow  
><mi  
>α</mi></mrow><mrow  
><mn>2</mn></mrow></msubsup 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>a</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>b</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
and          linearly          independent.          Then          an          orthonormal          set
<!--l. 277--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow  
><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mn>0</mn></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>…</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo></mrow></math>
such that
   <table  class="equation-star"><tr><td>
                                                                            
                                                                            
<!--l. 280--><math  
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="block" class="equation">
              <msub><mrow  
><mi  
>ϕ</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-rel" stretchy="false">=</mo> <msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>n</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>0</mn></mrow></msub 
><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mn>0</mn></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <mo  
class="MathClass-rel" stretchy="false">⋯</mo> <mo  
class="MathClass-bin" stretchy="false">+</mo> <msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>n</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>n</mi></mrow></msub 
><msub><mrow  
><mi  
>f</mi></mrow><mrow  
><mi  
>n</mi></mrow></msub 
><mo  
class="MathClass-open" stretchy="false">(</mo><mi  
>x</mi><mo  
class="MathClass-close" stretchy="false">)</mo><mspace  width="1em" class="quad"/><mi  
class="MathClass-op">∀</mi><mo> ⁡<!--FUNCTION APPLICATION--></mo><mi  
>n</mi> <mo  
class="MathClass-rel" stretchy="false">=</mo> <mn>0</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mn>1</mn><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>…</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>l</mi><mspace  width="1em" class="quad"/><msub><mrow  
><mi  
>λ</mi></mrow><mrow  
><mi  
>n</mi><mo  
class="MathClass-punc" stretchy="false">,</mo><mi  
>n</mi></mrow></msub 
> <mo  
class="MathClass-rel" stretchy="false">&#x003E;</mo> <mn>0</mn><mo  
class="MathClass-punc" stretchy="false">.</mo>
</math></td></tr></table>
<!--l. 286--><p  class="indent" >   Furthermore this set is <span  
class="cmti-10">uniquely determined</span>.
<!--l. 287--><p  class="indent" >   <a  
 id="refsection:45"></a></div>
<!--l. 287--><p  class="indent" >
<!--l. 289--><p  class="indent" >   <a  
 id="refsection:46"></a><a  
 id="x1-84r24"></a>
   <div  class="newtheorem">
<!--l. 289--><p  class="noindent" ><span  class="head">
<a  
 id="ckyn0xr9"></a>
<span  
class="cmbx-10">Literature – </span>Classical<br  
class="newline" /> </span><a  
 id="x1-86"></a><a  
 id="ckyn0xr9"></a>The classical work for orthogonal polynomials is the book [<a  
 id="x1-87"></a><a  
href="#cite.46@szeg1939orthogonal">Sze39</a>].
The  fourth  edition  (published  in  1975)  contains  the  classical  theory  of  orthogonal
polynomials, special cases such as Jacobi, Laguerre and Hermite polynomials, inequalities
and applications.
<!--l. 296--><p  class="indent" >   Another classic is the book by Freud [<a  
 id="x1-88"></a><a  
href="#cite.46@freud2014orthogonal">Fre14</a>], which gives a more compact and specialized
treatment of the topic.
<!--l. 300--><p  class="indent" >   For a recent survey of orthogonal polynomials [<a  
 id="x1-89"></a><a  
href="#cite.46@totik2005orthogonal">Tot05</a>] discusses the [ <a  
href="#cite.46@totik2005orthogonal">Tot05</a>,  <a  
href="https://arxiv.org/pdf/math/0512424.pdf#search=Some" questions leading to >origin</a> ] and
extended topics on them.
<!--l. 304--><p  class="indent" >   A application oriented treatment of orthogonal polynomials is the book by Gautschi
[<a  
 id="x1-90"></a><a  
href="#cite.46@gautschi2004orthogonal">Gau04</a>], especially the [ <a  
href="#cite.46@gautschi2004orthogonal">Gau04</a>,   <a  
href="https://csclub.uwaterloo.ca/~pbarfuss/Walter_Gautschi_-_Orthogonal_Polynomials_-_Computation_and_Approximation_(2004).pdf#search=2" Computational Methods >computational methods</a> ] and [ <a  
href="#cite.46@gautschi2004orthogonal">Gau04</a>,   <a  
href="https://csclub.uwaterloo.ca/~pbarfuss/Walter_Gautschi_-_Orthogonal_Polynomials_-_Computation_and_Approximation_(2004).pdf#search=3" Applications >application</a> ]
chapters are interesting extension of the other material.
          <dl  class="thebibliography"><dt  id="X46-freud2014orthogonal" class="thebibliography">
[Fre14]    </dt><dd  
id="bib-14" class="thebibliography">
          <!--l. 308--><p  class="noindent" ><a  
 id="cite.46@freud2014orthogonal"></a>Géza Freud. <span  
class="cmti-10">Orthogonal polynomials</span>. Elsevier, 2014.
          </dd><dt  id="X46-gautschi2004orthogonal" class="thebibliography">
[Gau04]   </dt><dd  
id="bib-15" class="thebibliography">
          <!--l. 308--><p  class="noindent" ><a  
 id="cite.46@gautschi2004orthogonal"></a>Walter Gautschi. <span  
class="cmti-10">Orthogonal polynomials: computation and approximation</span>. OUP
          Oxford, 2004. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://csclub.uwaterloo.ca/~pbarfuss/Walter_Gautschi_-_Orthogonal_Polynomials_-_Computation_and_Approximation_(2004).pdf" class="url" ><span  
class="cmtt-10">https://csclub.uwaterloo.ca/</span><span  
class="cmtt-10">~</span><span  
class="cmtt-10">pbarfuss/Walter_Gautschi_-_Orthogonal_Polynomials_-_Computation_and_Approximation_(2004).pdf</span></a>.
          </dd><dt  id="X46-szeg1939orthogonal" class="thebibliography">
[Sze39]    </dt><dd  
id="bib-16" class="thebibliography">
          <!--l. 308--><p  class="noindent" ><a  
 id="cite.46@szeg1939orthogonal"></a>Gabor  Szeg.  <span  
class="cmti-10">Orthogonal polynomials</span>.  Vol. 23.  American  Mathematical  Soc.,
          1939. <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://people.math.osu.edu/nevai.1/SZEGO/szego=szego1975=ops=OCR.pdf" class="url" ><span  
class="cmtt-10">https://people.math.osu.edu/nevai.1/SZEGO/szego=szego1975=ops=OCR.pdf</span></a>.
          </dd><dt  id="X46-totik2005orthogonal" class="thebibliography">
[Tot05]    </dt><dd  
id="bib-17" class="thebibliography">
          <!--l. 308--><p  class="noindent" ><a  
 id="cite.46@totik2005orthogonal"></a>Vilmos  Totik.  “Orthogonal  polynomials”.  In:  <span  
class="cmti-10">arXiv  preprint  math/0512424</span>
          (2005). <span  
class="cmcsc-10"><span  
class="small-caps">u</span><span  
class="small-caps">r</span><span  
class="small-caps">l</span></span>: <a  
href="https://arxiv.org/pdf/math/0512424.pdf" class="url" ><span  
class="cmtt-10">https://arxiv.org/pdf/math/0512424.pdf</span></a>.</dd></dl>
<!--l. 308--><p  class="indent" >   <a  
 id="refsection:47"></a></div>
<!--l. 308--><p  class="indent" >
<!--l. 309--><p  class="indent" >   <a  
 id="refsection:48"></a></div>
<!--l. 309--><p  class="indent" >
    
</body> 
</html>
                                                                            


